"""
```
draw_stationary_VAR(YYYYC, XXYYC, XXXXC, TÃÑ, n_obs, lags; testing = false,
                    test_Œ£_draw = [], test_Œ≤_draw = [])
draw_stationary_VAR(YYYYC, XXYYC, XXXXC, TÃÑ; testing = false,
                    test_Œ£_draw = [], test_Œ≤_draw = [])
```
draws Œ≤ and Œ£ from the distribution p(Œ≤, Œ£ | Y, Œ∏) implied by the
population moments (or covariances) YYYYC, XXYYC, and XXXXC for a
VAR with parameters Œ∏.

For example, if these population moments are generated by
a DSGE-VAR, then Œ∏ are the structural parameters of the DSGE
and the weight Œª placed on the cross-restrictions implied
by the DSGE. The population moments would represent the
moments of the sample data and dummy observables generated
to implement the DSGE prior.

Given these moments, we compute the maximum-likelihood
estimates of Œ≤ and Œ£ using OLS. Denote these estimates
by Œí and S. Then we generate draws from p(Œ≤, Œ£ | Y, Œ∏)
using the fact that
```
Œ£ | Y, Œ∏ ‚àº ‚Ñêùí≤ (TÃÑ √ó S, TÃÑ - (1 + lags * n_obs), n_obs),
Œ≤ | Y, Œ£,Œ∏ ‚àº ùí© (B, Œ£ ‚äó XXXXC‚Åª¬π).
```
Finally, we check that these draws generate a stationary
state space system. If they do not, then we keep drawing
until we obtain a pair of draws (Œ≤, Œ£) that are stationary.

### Inputs
* `YYYYC::Matrix{<:Real}`: covariance of observables
* `XXYYC::Matrix{<:Real}`: covariance of observables with their lags
* `XXXXC::Matrix{<:Real}`: covariance of the lags of the observables
* `TÃÑ::Int`: total number of time periods of observations, including sample observables
    from actual data and any dummy observables generated to implement priors.
* `n_obs::Int`: number of distint observables
* `lags::Int`: number of lags in the VAR

### Keywords
* All keywords are used for testing purposes.
"""
function draw_stationary_VAR(YYYYC::Matrix{S}, XXYYC::Matrix{S}, XXXXC::Matrix{S},
                             TÃÑ::Int, n_obs::Int, lags::Int; testing::Bool = false,
                             test_Œ£_draw::Matrix{S} = Matrix{S}(undef, 0, 0),
                             test_Œ≤_draw::Vector{S} = Vector{S}(undef, 0)) where {S<:Real}

    # Set up
    k = 1 + lags * n_obs
    inv_XXXXC = inv(XXXXC)
    Œ≤ = inv_XXXXC * XXYYC
    inv_Œ£_mul_TÃÑ = inv(YYYYC - XXYYC' * Œ≤)
    inv_Œ£_mul_TÃÑ += inv_Œ£_mul_TÃÑ' # force to be positive definite
    inv_Œ£_mul_TÃÑ ./= 2.
    cholmat = cholesky(inv_Œ£_mul_TÃÑ).L

    Œ≤ = vec(Œ≤)
    Œ≤_draw = similar(Œ≤)
    Œ£_draw = similar(inv_Œ£_mul_TÃÑ)
    if testing # just do one draw each
        # Draw from marginal posterior of Œ£ (based on DSGE-VAR)
        z = cholmat * test_Œ£_draw
        Œ£_draw = inv(z * z')

        # Draw from the conditional posterior of Œ≤ (based on DSGE-VAR)
        vc       = kron(Œ£_draw, inv_XXXXC)
        vc       += vc'
        vc       ./= 2.
        Œ≤_draw   = convert(Matrix{S}, reshape(Œ≤ + cholesky(vc).L * test_Œ≤_draw, k, n_obs)')
    else
        stationary = false
        while !stationary
            # Draw from marginal posterior of Œ£ (based on DSGE-VAR)
            z = cholmat * randn(n_obs, TÃÑ - k)
            Œ£_draw = inv(z * z')

            # Draw from the conditional posterior of Œ≤ (based on DSGE-VAR)
            vc       = kron(Œ£_draw, inv_XXXXC)
            vc       += vc'
            vc       ./= 2.
            Œ≤_draw   = convert(Matrix{S}, reshape(Œ≤ + cholesky(vc).L * randn(n_obs * k), k, n_obs)')
            Œ≤_to_TTT = vcat(Œ≤_draw[:, (1+1):k],
                            hcat(Matrix{S}(I, n_obs * (lags - 1), n_obs * (lags - 1)),
                                 zeros(S, n_obs * (lags - 1), n_obs)))
            if maximum(abs.(eigen(Œ≤_to_TTT).values)) < 1
                stationary = true
            end
        end
    end

    return Œ≤_draw, Œ£_draw
end

function draw_stationary_VAR(YYYYC::Matrix{S}, XXYYC::Matrix{S}, XXXXC::Matrix{S},
                             TÃÑ::Int; testing::Bool = false,
                             test_Œ£_draw::Matrix{S} = Matrix{S}(undef, 0, 0),
                             test_Œ≤_draw::Vector{S} = Vector{S}(undef, 0)) where {S<:Real}
    # Infer n_obs and lags from population moments
    n_obs = size(YYYYC, 1)
    lags = (size(XXXXC, 1) - 1) / n_obs

    return draw_stationary_VAR(YYYYC, XXYYC, XXXXC, TÃÑ, n_obs, lags; testing = testing,
                               test_Œ£_draw = test_Œ£_draw, test_Œ≤_draw = test_Œ≤_draw)
end
